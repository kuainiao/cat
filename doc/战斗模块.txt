方案尚待完善


[一致性方案]

* 分包方案:
FRONTEND:
1. 发送攻击信息(skillid,character_id)
BACKEND
2. 攻击模块handle攻击请求. (角色/怪物 进程)
	1). ets中获取 场景信息 技能信息 玩家坐标信息
	2). 计算范围得到 受击对象(这个其实可移到前端)
	3). 发请求给各个攻击/受击对象的相应进程
			受击者进程计算并变更自身状态
			受击者发各自受击数据包给FRONTEND
	4). ets更新自身状态(自身进程，无一致性问题)
	5). 返回攻击应答(成功发招)

FRONTEND:
3. 接受到攻击应答(发招)
4. 接受到各自怪物的攻击应答(skillid,character_id,hp,mp..) 对应展示受击效果.


特征:
	1. 并发高时: 吞吐适中(主要看IO能力), 延迟优
	适合大场景实时游戏, ARPG, 但群攻密集型不适合.(IO和 吞吐+延迟的取舍平衡)
优点:
	1. 无需异步等待(重点). 确保一致性(重点)
缺点:
	1. 消息冗余(不严重)
方案评级: 良



独立battle进程方案(解除双向依赖)
FRONTEND:
1. 发送攻击信息(skillid,character_id)
BACKEND
2. 攻击模块handle攻击请求. (独立battle进程)
	1). ets中获取 场景信息 技能信息 玩家坐标信息
	2). 计算范围得到 受击对象(这个其实可移到前端)
	3). 发请求给各个攻击者/受击者对象的相应进程
			攻击者/受击者进程计算并变更自身状态
	4). 等待进程返回信息并聚合
	5). 返回攻击应答(成功发招)

FRONTEND:
3. 接受到攻击应答(发招, 受击), 展示效果


特征:
	1. 并发优，吞吐适中, 延迟适中(适合大场景准实时游戏, 回合制)
优点:
	1. 一致性, 业务模型统一
缺点:
	1. 需要进程等待(不严重), 性能会有一定影响.
	2. 等待有轻微优先级倒置问题. 如果 堆积攻击请求过多，会使得应答同步等待效率过低. (量大有影响)
方案评级: 优



NOTE: 若由场景进程负责战斗, 则可统一直接操作ets来维护状态变更. 包括加/扣减hp,mq. 可具体测量场景负载.

特征:
	1. 并发低时: 吞吐优, 延迟小
	2. 并发高时: 吞吐小, 延迟大
	(适合小场景实时游戏, CS类游戏)
优点: 
	1. 并发增加(请求排队, 会导致部分请求优先级倒置), 一致性保证.
缺点: 平均延迟增加.